---
title: "Ethereum to Aptos Cheatsheet"
---

import { Tabs, Callout } from 'nextra/components'

# Ethereum to Aptos Cheatsheet

This cheatsheet provides a comprehensive comparison between Ethereum and Aptos blockchain development, helping Ethereum developers transition to Aptos and the Move programming language. It highlights key differences in programming models, storage patterns, and security features.

To learn more about Aptos and Move concepts, try the [Ethereum to Aptos workshop on Aptos Learn](https://learn.aptoslabs.com/en/workshops/eth-to-aptos)

![Diagram](/docs/move-vs-solidity.svg)

## Key Takeaways for Ethereum Developers

- **Contract vs Resource Model**: In Solidity, tokens are implemented as state variables in contracts with functions that modify them. In Move, tokens are native "resource" types with built-in move semantics (cannot be copied or discarded, only moved between storage locations) enforced by the compiler.

- **Storage Architecture**: Ethereum uses contract-centric storage where data lives within contracts. Aptos uses an account-centric model where both code (modules) and data (resources) are stored in accounts, fundamentally changing how you structure applications.

- **Security Approach**: Solidity relies on careful implementation to prevent vulnerabilities. Move's type system and bytecode verifier enforce security properties at the language level, making certain classes of bugs (like reentrancy) impossible by design.

- **Execution Model**: Ethereum's EVM uses dynamic dispatch allowing arbitrary contract calls at runtime. Move uses static dispatch with explicit imports, making code execution more predictable and enabling better compiler optimizations.

<Callout type="info">
**Move's "First-Class" Security**

In programming language theory, "first-class" means that a type or value can be:

1. Passed as an argument to functions
2. Returned from functions
3. Assigned to variables
4. Stored in data structures

In Solidity, tokens are implemented through state variables and functions in a contract, but they aren't first-class citizens of the language itself.

In Move, resources are built into the language's type system with special semantics enforced by the compiler. 

This fundamental difference means Move can provide stronger guarantees about how digital assets behave, preventing issues like double-spending or asset loss at the language level rather than through careful implementation.
</Callout>

---

### High Level Overview

| Feature                    | Ethereum                                                                                                                       | Aptos                                                                                                                                 |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| **Smart Contracts**        | Solidity, EVM                                                                                                                  | Move, MoveVM                                                                                                                          |
| **Benefits**               | Mature, wide adoption                                                                                                          | Scalability, low latency, predictable fees                                                                                            |
| **Transaction Fees**       | Variable, can be high                                                                                                          | Lower and more predictable                                                                                                            |
| **Account Addresses**      | 160-bit                                                                                                                        | 256-bit                                                                                                                               |
| **Account Structure**      | Balance in a single field, uses nonce                                                                                          | Modules and resources, uses sequence number                                                                                           |
| **Data Storage**           | Patricia Merkle Trees                                                                                                          | Global storage with resources and modules                                                                                             |
| **Storage Mindset**        | Contract-based storage                                                                                                         | Account centric mindset for code and data                                                                                             |
| **Example Code**           | [ERC-20](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20)                             | [Fungible Asset](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/fungible_asset.move) |
| **Caller ID**              | `msg.sender`                                                                                                                   | `&signer` reference                                                                                                                   |
| **Upgradeability**         | Proxy patterns                                                                                                                 | Direct module upgrades                                                                                                                |
| **Safety & Security**      | Vulnerable to attacks like reentrancy                                                                                          | Mitigates common vulnerabilities                                                                                                      |
| **Dispatch Type**          | Dynamic dispatch                                                                                                               | Static dispatch                                                                                                                       |
| **FT Standard**            | [ERC-20](https://docs.openzeppelin.com/contracts/4.x/erc20)                                                                    | [Coin](../smart-contracts/aptos-coin.mdx) (legacy) and [Fungible Asset](../smart-contracts/fungible-asset.mdx)  |
| **NFT Standards**          | [ERC-721](https://docs.openzeppelin.com/contracts/4.x/erc721), [ERC-1155](https://docs.openzeppelin.com/contracts/4.x/erc1155) | [Digital Asset](../smart-contracts/digital-asset.mdx)                                                                      |
| **Blockchain Interaction** | [Ethers.js library](https://docs.ethers.org/v6/)                                                                               | [Aptos Typescript SDK](../sdks/ts-sdk.mdx)                                                                                |

<br />

### Comparing Token Standards in Detail

|                        | Solidity                                                          | Move (Aptos)                                                                                                                                                    |
| ---------------------- | ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Token Structure**    | Each token is its own contract.                                   | Every token is a typed `Coin` or `FungibleAsset` using a single, reusable contract.                                                                             |
| **Token Standard**     | Must conform to standards like ERC20; implementations can vary.   | Uniform interface and implementation for all tokens.                                                                                                            |
| **Balance Storage**    | Balances stored in contract using a mapping structure.            | **Resource-Oriented Balance**: Balances stored as a resource in the user's account. Resources cannot be arbitrarily created, ensuring integrity of token value. |
| **Transfer Mechanism** | Tokens can be transferred without receiver's explicit permission. | Except for specific cases (like AptosCoin), Tokens generally require receiver's `signer` authority for transfer.                                                |

<br />

### Comparing EVM and Move VM in Detail

- **EVM**: Known for its flexibility and dynamic dispatch, which allows a wide range of smart contract behaviors. This flexibility, however, can lead to complexities in parallel execution and network operations.
- **Move VM**: Focuses on safety and efficiency with a more integrated approach between the VM and the programming language. Its data storage model allows for better parallelization, and its static dispatch method enhances security and predictability.

<br />

|                                 | EVM (Ethereum Virtual Machine)                                         | Move VM (Move Virtual Machine)                                                                                     |
| ------------------------------- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| **Data Storage**                | Data is stored in the smart contract's storage space.                  | Data is stored across smart contracts, user accounts, and objects.                                                 |
| **Parallelization**             | Parallel execution is limited due to shared storage space.             | More parallel execution enabled due to flexible split storage design.                                              |
| **VM and Language Integration** | Separate layers for EVM and smart contract languages (e.g., Solidity). | Seamless integration between VM layer and Move language, with native functions written in Rust executable in Move. |
| **Critical Network Operations** | Implementation of network operations can be complex and less direct.   | Critical operations like validator set management natively implemented in Move, allowing for direct execution.     |
| **Function Calling**            | Dynamic dispatch allows for arbitrary smart contract calls.            | Static dispatch aligns with a focus on security and predictable behavior.                                          |
| **Type Safety**                 | Contract types provide a level of type safety.                         | Module structs and generics in Move offer robust type safety.                                                      |
| **Transaction Safety**          | Uses nonces for transaction ordering and safety.                       | Uses sequence numbers for transaction ordering and safety.                                                         |
| **Authenticated Storage**       | Yes, with smart contract storage.                                      | Yes, leveraging Move's resource model.                                                                             |
| **Object Accessibility**        | Objects are not globally accessible; bound to smart contract scope.    | Guaranteed global accessibility of objects.                                                                        |

---

## Side-by-Side Code Examples

### Token Transfer Implementation

<Tabs items={['Solidity (ERC-20)', 'Move (Fungible Asset)']}>
  <Tabs.Tab>
    ```solidity
    // ERC-20 Transfer
    function transfer(address to, uint256 amount) public returns (bool) {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```move
    // Fungible Asset Transfer
    public fun transfer(
        sender: &signer,
        id: Object<Metadata>,
        to: address,
        amount: u64,
    ) {
        let sender_addr = signer::address_of(sender);
        let sender_store = ensure_fungible_asset_store_exists(sender_addr);
        let receiver_store = ensure_fungible_asset_store_exists(to);
        
        let fa = withdraw(sender_store, id, amount);
        deposit(receiver_store, fa);
    }
    ```
  </Tabs.Tab>
</Tabs>

### Key Differences Highlighted

- **Solidity**: Uses a global mapping for balances, directly modifies state
- **Move**: Uses resource-oriented programming with explicit withdraw/deposit operations
- **Safety**: Move enforces that assets cannot be duplicated or lost during transfers
- **Authorization**: Move requires a signer reference for the sender, providing stronger authorization
